{"version":3,"sources":["ysera.js"],"names":[],"mappings":"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","file":"ysera.js","sourcesContent":["/** @module Ysera*/\nimport { Server as server } from 'http';\nimport urlencoded from './urlencoded';\nimport { generate } from 'url-match';\nimport { parse } from 'url';\nimport boot from './serve';\nimport json from './json';\n\nconst DEV = process.env.NODE_ENV === 'development',\n    CACHE = {};\n\n/** Class representing Ysera */\nexport default class Ysera {\n    /**\n     * Serves\n     *\n     */\n    static serve(fn, { onError = null } = {}) {\n        return server((req, res) => {\n            Ysera.run(req, res, fn, onError || Ysera.sendError);\n        });\n    }\n\n    /**\n     * Runs\n     *\n     */\n    static async run(req, res, fn, onError) {\n        try {\n            const val = await fn(req, res);\n\n            if (val !== null) {\n                this.send(res, 200, val);\n            }\n        } catch (error) {\n            await onError(req, res, error);\n        }\n    }\n\n    /**\n     * Sends.\n     *\n     */\n    static send(res, code, object = null) {\n        res.statusCode = code;\n        if (object === null) {\n            return res.end();\n        }\n\n        let string;\n        if (typeof object === 'object') {\n            // we stringify before setting the header\n            // in case `JSON.stringify` throws and a\n            // 500 has to be sent instead\n\n            // the `JSON.stringify` call is split into\n            // two cases as `JSON.stringify` is optimized\n            // in V8 if called with only one argument\n            string = DEV\n                ? JSON.stringify(object, null, 2) : JSON.stringify(object);\n            res.setHeader('Content-Type', 'application/json');\n        } else {\n            string = object;\n        }\n\n        // set content length\n        res.setHeader('Content-Length', Buffer.byteLength(string));\n        res.end(string);\n    }\n\n    /**\n     * Sends error.\n     *\n     * @param {http.IncomingMessage} req\n     * @param {http.OutgoingMessage} res\n     */\n    static sendError(req, res, { code, message, stack }) {\n        if (code) {\n            this.send(res, code, DEV ? stack : message);\n        } else {\n            this.send(res, 500, DEV ? stack : 'Internal Server Error');\n        }\n        // FIXME: log the error\n        return stack;\n    }\n\n    static parseMeta(req, options = {}) {\n        const { method, headers, url } = req,\n            parsedUrl = parse(url, true),\n            { path, pathname, query } = parsedUrl,\n            { pattern } = options,\n            parsed = {\n                method,\n                headers,\n                url,\n                path,\n                pathname,\n                query,\n                hasPattern: false\n            };\n\n        parsed.headers = {};\n        for (let key in headers) {\n            parsed.headers[key.toLowerCase()] = headers[key];\n        }\n\n        // if we have pattern to match, e.g. /hihi/:version/:id\n        // and given /hihi/1/haha, then we should get\n        // { version: 1, id: 'haha' } as the params object.\n        if (pattern) {\n            const compiled = CACHE[pattern] || (CACHE[pattern] = generate(pattern)),\n                matched = compiled.match(parsed.path);\n            parsed.hasPattern = true;\n            parsed.pattern = pattern;\n            if (!matched) {\n                parsed.matched = false;\n                return parsed;\n            }\n            parsed.matched = true;\n            parsed.query = matched.queryParams;\n            parsed.params = matched.namedParams;\n        }\n\n        return parsed;\n    }\n\n    static async parseBody(req, options = {}) {\n        const parsed = {};\n        if ([ 'POST', 'PUT' ].indexOf(req.method) >= 0) {\n            parsed.body = await urlencoded(req, options) || await json(req, options) || {};\n        }\n        return parsed;\n    }\n\n    /**\n     * Parses the request.\n     *\n     * @param {http.IncomingRequest} req\n     * @param {Object} options\n     */\n    static async parse(req, options = {}) {\n        const parsed = Ysera.parseMeta(req, options);\n        Object.assign(parsed, await Ysera.parseBody(req, options));\n        return parsed;\n    }\n\n    static boot(fn, port = 3000) {\n        boot(fn, port);\n    }\n}\n"],"sourceRoot":"/Users/diorahman/Experiments/hooq/src/luigi/micro-core/lib"}